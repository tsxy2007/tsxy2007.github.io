---
title: DirectX12-混合
date: 2021-10-02 21:31:05
tags: DirectX12
---
## 混合方程：
```
//控制颜色RGB分量
C = C(源) X F(源) + C(目标) X F(目标)
//控制alpha分量
A = A(源) X A(源) + A(目标) X A(目标)
```
## 混合运算

```
// 枚举成员将用作混合方程中的二元运算符：
// alpha 同样适用于alpha项
typedef enum D3D12_BLEND_OP
{
    D3D12_BLEND_OP_ADD = 1, 加法
    D3D12_BLEND_OP_SUBTRACT = 2, 源-目标
    D3D12_BLEND_OP_REV_SUBTRACT = 3, 目标-源
    D3D12_BLEND_OP_MIN=4,min（源，目标）
    D3D12_BLEND_OP_MAX =5 max（源，目标）
} D3D12_BLEND_OP
//通过逻辑运算符对源颜色和目标颜色进行混合，用以取代上述传统的混合方程，
// 但是两种方式只能取其一；
typedef enum D3D12_LOGIC_OP
{
    D3D12_LOGIC_OP_CLEAR =0 ,
    D3D12_LOGIC_OP_SET = (D3D12_LOGIC_OP_CLEAR + 1),
    D3D12_LOGIC_OP_COPY = (D3D12_LOGIC_OP_SET+1),
    D3D12_LOGIC_OP_COPY_INVERTED = (D3D12_LOGIC_OP_COPY+1),
    D3D12_LOGIC_OP_NOOP = (D3D12_LOGIC_OP_COPY_INVERTED+1),
    D3D12_LOGIC_OP_INVERT = (D3D12_LOGIC_OP_NOOP+1),
    D3D12_LOGIC_OP_AND = (D3D12_LOGIC_OP_INVERT+1),
    D3D12_LOGIC_OP_NAND = (D3D12_LOGIC_OP_AND+1),
    D3D12_LOGIC_OP_OR =(D3D12_LOGIC_OP_NAND+1),
    D3D12_LOGIC_OP_NOR = (D3D12_LOGIC_OP_OR+1),
    D3D12_LOGIC_OP_XOR = (D3D12_LOGIC_OP_NOR+1),
    D3D12_LOGIC_OP_EQUIV = (D3D12_LOGIC_OP_XOR+1),
    D3D12_LOGIC_OP_AND_REVERSE = (D3D12_LOGIC_OP_EQUIV+1),
    D3D12_LOGIC_OP_AND_INVERTED = (D3D12_LOGIC_OP_AND_REVERSE+1),
    D3D12_LOGIC_OP_OR_REVERSE = (D3D12_LOGIC_OP_AND_INVERTED+1),
    D3D12_LOGIC_OP_INVERTED = (D3D12_LOGIC_OP_OR_REVERSE+1),
} D3D12_LOGIC_OP
```
## 混合因子
D3D12_BLEND_ZERO: F=(0,0,0)且 F = 0
D3D12_BLEND_ONE: F=(1,1,1)且 F= 1
D3D12_BLEND_SRC_COLOR: F=(rs,gs,bs) 
D3D12_BLEND_INV_SRC_COLOR:
D3D12_BLEND_SRC_ALPHA :
D3D12_BLEND_INV_SRC_ALPHA:
D3D12_BLEND_DEST_ALPHA:
D3D12_BLEND_INV_DEST_ALPHA:
D3D12_BLEND_DEST_COLOR:
D3D12_BLEND_INV_DEST_COLOR:
D3D12_BLEND_SRC_ALPHA_SAT
D3D12_BLEND_BLEND_FACTOR:
```
// 设置混合因子
void ID3D12CraphicsCommandList::OMSetBlendFactor(const FLOAT BlendFactor[4]);
```
## 混合状态
